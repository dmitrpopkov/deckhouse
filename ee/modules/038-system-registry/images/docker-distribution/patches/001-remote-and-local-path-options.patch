diff --git a/configuration/configuration.go b/configuration/configuration.go
index 7076df85..35d9f435 100644
--- a/configuration/configuration.go
+++ b/configuration/configuration.go
@@ -650,6 +650,12 @@ type Proxy struct {
 
 	// Password of the hub user
 	Password string `yaml:"password"`
+
+	// RemotePathOnly specifies the registry path where requests are allowed to be executed
+	RemotePathOnly string `yaml:"remotepathonly"`
+
+	// LocalPathAlias renames the remote path to allow access to the registry via a local path alias
+	LocalPathAlias string `yaml:"localpathalias"`
 }
 
 // Parse parses an input configuration yaml document into a Configuration struct
diff --git a/errors.go b/errors.go
index 8e0b788d..0ba113d5 100644
--- a/errors.go
+++ b/errors.go
@@ -117,3 +117,14 @@ type ErrManifestNameInvalid struct {
 func (err ErrManifestNameInvalid) Error() string {
 	return fmt.Sprintf("manifest name %q invalid: %v", err.Name, err.Reason)
 }
+
+// ErrRepositoryUnknownWithReason is returned if the named repository is not known by
+// the registry, along with the reason for this status.
+type ErrRepositoryUnknownWithReason struct {
+	Name   string
+	Reason error
+}
+
+func (err ErrRepositoryUnknownWithReason) Error() string {
+	return fmt.Sprintf("repository '%s' is not known to the registry: %v", err.Name, err.Reason)
+}
diff --git a/registry/handlers/app.go b/registry/handlers/app.go
index bf56cea2..fa87f23a 100644
--- a/registry/handlers/app.go
+++ b/registry/handlers/app.go
@@ -692,6 +692,8 @@ func (app *App) dispatcher(dispatch dispatchFunc) http.Handler {
 				switch err := err.(type) {
 				case distribution.ErrRepositoryUnknown:
 					context.Errors = append(context.Errors, v2.ErrorCodeNameUnknown.WithDetail(err))
+				case distribution.ErrRepositoryUnknownWithReason:
+					context.Errors = append(context.Errors, v2.ErrorCodeNameUnknown.WithMessage(err.Error()))
 				case distribution.ErrRepositoryNameInvalid:
 					context.Errors = append(context.Errors, v2.ErrorCodeNameInvalid.WithDetail(err))
 				case errcode.Error:
diff --git a/registry/proxy/proxyblobstore.go b/registry/proxy/proxyblobstore.go
index 5605e077..cd7db713 100644
--- a/registry/proxy/proxyblobstore.go
+++ b/registry/proxy/proxyblobstore.go
@@ -15,11 +15,12 @@ import (
 )
 
 type proxyBlobStore struct {
-	localStore     distribution.BlobStore
-	remoteStore    distribution.BlobService
-	scheduler      *scheduler.TTLExpirationScheduler
-	repositoryName reference.Named
-	authChallenger authChallenger
+	localStore           distribution.BlobStore
+	remoteStore          distribution.BlobService
+	scheduler            *scheduler.TTLExpirationScheduler
+	localRepositoryName  reference.Named
+	remoteRepositoryName reference.Named
+	authChallenger       authChallenger
 }
 
 var _ distribution.BlobStore = &proxyBlobStore{}
@@ -140,7 +141,7 @@ func (pbs *proxyBlobStore) ServeBlob(ctx context.Context, w http.ResponseWriter,
 			dcontext.GetLogger(ctx).Errorf("Error committing to storage: %s", err.Error())
 		}
 
-		blobRef, err := reference.WithDigest(pbs.repositoryName, dgst)
+		blobRef, err := reference.WithDigest(pbs.localRepositoryName, dgst)
 		if err != nil {
 			dcontext.GetLogger(ctx).Errorf("Error creating reference: %s", err)
 			return
diff --git a/registry/proxy/proxyblobstore_test.go b/registry/proxy/proxyblobstore_test.go
index 8141b8e7..d05bbd3a 100644
--- a/registry/proxy/proxyblobstore_test.go
+++ b/registry/proxy/proxyblobstore_test.go
@@ -116,8 +116,12 @@ func (te *testEnv) RemoteStats() *map[string]int {
 }
 
 // Populate remote store and record the digests
-func makeTestEnv(t *testing.T, name string) *testEnv {
-	nameRef, err := reference.WithName(name)
+func makeTestEnv(t *testing.T, localName, remoteName string) *testEnv {
+	localNameRef, err := reference.WithName(localName)
+	if err != nil {
+		t.Fatalf("unable to parse reference: %s", err)
+	}
+	remoteNameRef, err := reference.WithName(remoteName)
 	if err != nil {
 		t.Fatalf("unable to parse reference: %s", err)
 	}
@@ -146,7 +150,7 @@ func makeTestEnv(t *testing.T, name string) *testEnv {
 	if err != nil {
 		t.Fatalf("error creating registry: %v", err)
 	}
-	localRepo, err := localRegistry.Repository(ctx, nameRef)
+	localRepo, err := localRegistry.Repository(ctx, localNameRef)
 	if err != nil {
 		t.Fatalf("unexpected error getting repo: %v", err)
 	}
@@ -162,7 +166,7 @@ func makeTestEnv(t *testing.T, name string) *testEnv {
 	if err != nil {
 		t.Fatalf("error creating registry: %v", err)
 	}
-	truthRepo, err := truthRegistry.Repository(ctx, nameRef)
+	truthRepo, err := truthRegistry.Repository(ctx, remoteNameRef)
 	if err != nil {
 		t.Fatalf("unexpected error getting repo: %v", err)
 	}
@@ -180,11 +184,12 @@ func makeTestEnv(t *testing.T, name string) *testEnv {
 	s := scheduler.New(ctx, inmemory.New(), "/scheduler-state.json")
 
 	proxyBlobStore := proxyBlobStore{
-		repositoryName: nameRef,
-		remoteStore:    truthBlobs,
-		localStore:     localBlobs,
-		scheduler:      s,
-		authChallenger: &mockChallenger{},
+		localRepositoryName:  localNameRef,
+		remoteRepositoryName: remoteNameRef,
+		remoteStore:          truthBlobs,
+		localStore:           localBlobs,
+		scheduler:            s,
+		authChallenger:       &mockChallenger{},
 	}
 
 	te := &testEnv{
@@ -225,7 +230,7 @@ func populate(t *testing.T, te *testEnv, blobCount, size, numUnique int) {
 	te.numUnique = numUnique
 }
 func TestProxyStoreGet(t *testing.T) {
-	te := makeTestEnv(t, "foo/bar")
+	te := makeTestEnv(t, "foo/bar", "bar/foo")
 
 	localStats := te.LocalStats()
 	remoteStats := te.RemoteStats()
@@ -260,7 +265,7 @@ func TestProxyStoreGet(t *testing.T) {
 }
 
 func TestProxyStoreStat(t *testing.T) {
-	te := makeTestEnv(t, "foo/bar")
+	te := makeTestEnv(t, "foo/bar", "bar/foo")
 
 	remoteBlobCount := 1
 	populate(t, te, remoteBlobCount, 10, 1)
@@ -291,7 +296,7 @@ func TestProxyStoreStat(t *testing.T) {
 }
 
 func TestProxyStoreServeHighConcurrency(t *testing.T) {
-	te := makeTestEnv(t, "foo/bar")
+	te := makeTestEnv(t, "foo/bar", "bar/foo")
 	blobSize := 200
 	blobCount := 10
 	numUnique := 1
@@ -302,7 +307,7 @@ func TestProxyStoreServeHighConcurrency(t *testing.T) {
 }
 
 func TestProxyStoreServeMany(t *testing.T) {
-	te := makeTestEnv(t, "foo/bar")
+	te := makeTestEnv(t, "foo/bar", "bar/foo")
 	blobSize := 200
 	blobCount := 10
 	numUnique := 4
@@ -314,7 +319,7 @@ func TestProxyStoreServeMany(t *testing.T) {
 
 // todo(richardscothern): blobCount must be smaller than num clients
 func TestProxyStoreServeBig(t *testing.T) {
-	te := makeTestEnv(t, "foo/bar")
+	te := makeTestEnv(t, "foo/bar", "bar/foo")
 
 	blobSize := 2 << 20
 	blobCount := 4
diff --git a/registry/proxy/proxymanifeststore.go b/registry/proxy/proxymanifeststore.go
index 30714fbe..c5bb814a 100644
--- a/registry/proxy/proxymanifeststore.go
+++ b/registry/proxy/proxymanifeststore.go
@@ -15,12 +15,13 @@ import (
 const repositoryTTL = 24 * 7 * time.Hour
 
 type proxyManifestStore struct {
-	ctx             context.Context
-	localManifests  distribution.ManifestService
-	remoteManifests distribution.ManifestService
-	repositoryName  reference.Named
-	scheduler       *scheduler.TTLExpirationScheduler
-	authChallenger  authChallenger
+	ctx                  context.Context
+	localManifests       distribution.ManifestService
+	remoteManifests      distribution.ManifestService
+	localRepositoryName  reference.Named
+	remoteRepositoryName reference.Named
+	scheduler            *scheduler.TTLExpirationScheduler
+	authChallenger       authChallenger
 }
 
 var _ distribution.ManifestService = &proxyManifestStore{}
@@ -71,7 +72,7 @@ func (pms proxyManifestStore) Get(ctx context.Context, dgst digest.Digest, optio
 		}
 
 		// Schedule the manifest blob for removal
-		repoBlob, err := reference.WithDigest(pms.repositoryName, dgst)
+		repoBlob, err := reference.WithDigest(pms.localRepositoryName, dgst)
 		if err != nil {
 			dcontext.GetLogger(ctx).Errorf("Error creating reference: %s", err)
 			return nil, err
diff --git a/registry/proxy/proxymanifeststore_test.go b/registry/proxy/proxymanifeststore_test.go
index 4927dc1e..b60c0285 100644
--- a/registry/proxy/proxymanifeststore_test.go
+++ b/registry/proxy/proxymanifeststore_test.go
@@ -82,8 +82,12 @@ func (m *mockChallenger) challengeManager() challenge.Manager {
 	return nil
 }
 
-func newManifestStoreTestEnv(t *testing.T, name, tag string) *manifestStoreTestEnv {
-	nameRef, err := reference.WithName(name)
+func newManifestStoreTestEnv(t *testing.T, localName, remoteName, tag string) *manifestStoreTestEnv {
+	localNameRef, err := reference.WithName(localName)
+	if err != nil {
+		t.Fatalf("unable to parse reference: %s", err)
+	}
+	remoteNameRef, err := reference.WithName(remoteName)
 	if err != nil {
 		t.Fatalf("unable to parse reference: %s", err)
 	}
@@ -100,7 +104,7 @@ func newManifestStoreTestEnv(t *testing.T, name, tag string) *manifestStoreTestE
 	if err != nil {
 		t.Fatalf("error creating registry: %v", err)
 	}
-	truthRepo, err := truthRegistry.Repository(ctx, nameRef)
+	truthRepo, err := truthRegistry.Repository(ctx, remoteNameRef)
 	if err != nil {
 		t.Fatalf("unexpected error getting repo: %v", err)
 	}
@@ -113,7 +117,7 @@ func newManifestStoreTestEnv(t *testing.T, name, tag string) *manifestStoreTestE
 		stats:     make(map[string]int),
 	}
 
-	manifestDigest, err := populateRepo(ctx, t, truthRepo, name, tag)
+	manifestDigest, err := populateRepo(ctx, t, truthRepo, remoteName, tag)
 	if err != nil {
 		t.Fatalf(err.Error())
 	}
@@ -122,7 +126,7 @@ func newManifestStoreTestEnv(t *testing.T, name, tag string) *manifestStoreTestE
 	if err != nil {
 		t.Fatalf("error creating registry: %v", err)
 	}
-	localRepo, err := localRegistry.Repository(ctx, nameRef)
+	localRepo, err := localRegistry.Repository(ctx, localNameRef)
 	if err != nil {
 		t.Fatalf("unexpected error getting repo: %v", err)
 	}
@@ -140,12 +144,13 @@ func newManifestStoreTestEnv(t *testing.T, name, tag string) *manifestStoreTestE
 	return &manifestStoreTestEnv{
 		manifestDigest: manifestDigest,
 		manifests: proxyManifestStore{
-			ctx:             ctx,
-			localManifests:  localManifests,
-			remoteManifests: truthManifests,
-			scheduler:       s,
-			repositoryName:  nameRef,
-			authChallenger:  &mockChallenger{},
+			ctx:                  ctx,
+			localManifests:       localManifests,
+			remoteManifests:      truthManifests,
+			scheduler:            s,
+			localRepositoryName:  localNameRef,
+			remoteRepositoryName: remoteNameRef,
+			authChallenger:       &mockChallenger{},
 		},
 	}
 }
@@ -203,8 +208,9 @@ func populateRepo(ctx context.Context, t *testing.T, repository distribution.Rep
 // TestProxyManifests contains basic acceptance tests
 // for the pull-through behavior
 func TestProxyManifests(t *testing.T) {
-	name := "foo/bar"
-	env := newManifestStoreTestEnv(t, name, "latest")
+	localName := "foo/bar"
+	remoteName := "bar/foo"
+	env := newManifestStoreTestEnv(t, localName, remoteName, "latest")
 
 	localStats := env.LocalStats()
 	remoteStats := env.RemoteStats()
diff --git a/registry/proxy/proxyregistry.go b/registry/proxy/proxyregistry.go
index 8e5506ed..7d152248 100644
--- a/registry/proxy/proxyregistry.go
+++ b/registry/proxy/proxyregistry.go
@@ -5,6 +5,7 @@ import (
 	"fmt"
 	"net/http"
 	"net/url"
+	"strings"
 	"sync"
 
 	"github.com/distribution/reference"
@@ -26,10 +27,22 @@ type proxyingRegistry struct {
 	scheduler      *scheduler.TTLExpirationScheduler
 	remoteURL      url.URL
 	authChallenger authChallenger
+	remotePathOnly string
+	localPathAlias string
 }
 
 // NewRegistryPullThroughCache creates a registry acting as a pull through cache
 func NewRegistryPullThroughCache(ctx context.Context, registry distribution.Namespace, driver driver.StorageDriver, config configuration.Proxy) (distribution.Namespace, error) {
+	remotePathOnly := strings.Trim(strings.TrimSpace(config.RemotePathOnly), "/")
+	localPathAlias := strings.Trim(strings.TrimSpace(config.LocalPathAlias), "/")
+
+	if remotePathOnly == "" && localPathAlias != "" {
+		return nil, fmt.Errorf(
+			"unknown remote path for the alias of the local path '%s', fill in the 'proxy.remotepathonly' field",
+			localPathAlias,
+		)
+	}
+
 	remoteURL, err := url.Parse(config.RemoteURL)
 	if err != nil {
 		return nil, err
@@ -99,9 +112,11 @@ func NewRegistryPullThroughCache(ctx context.Context, registry distribution.Name
 	}
 
 	return &proxyingRegistry{
-		embedded:  registry,
-		scheduler: s,
-		remoteURL: *remoteURL,
+		embedded:       registry,
+		scheduler:      s,
+		remoteURL:      *remoteURL,
+		remotePathOnly: remotePathOnly,
+		localPathAlias: localPathAlias,
 		authChallenger: &remoteAuthChallenger{
 			remoteURL: *remoteURL,
 			cm:        challenge.NewSimpleManager(),
@@ -119,6 +134,16 @@ func (pr *proxyingRegistry) Repositories(ctx context.Context, repos []string, la
 }
 
 func (pr *proxyingRegistry) Repository(ctx context.Context, name reference.Named) (distribution.Repository, error) {
+	localRepositoryName := name
+	remoteRepositoryName, err := pr.getRemoteRepositoryName(name)
+	if err != nil {
+		return nil, err
+	}
+
+	if _, err = pr.repositoryIsAllowed(name); err != nil {
+		return nil, err
+	}
+
 	c := pr.authChallenger
 
 	tkopts := auth.TokenHandlerOptions{
@@ -126,7 +151,7 @@ func (pr *proxyingRegistry) Repository(ctx context.Context, name reference.Named
 		Credentials: c.credentialStore(),
 		Scopes: []auth.Scope{
 			auth.RepositoryScope{
-				Repository: name.Name(),
+				Repository: remoteRepositoryName.Name(),
 				Actions:    []string{"pull"},
 			},
 		},
@@ -137,7 +162,7 @@ func (pr *proxyingRegistry) Repository(ctx context.Context, name reference.Named
 		auth.NewAuthorizer(c.challengeManager(),
 			auth.NewTokenHandlerWithOptions(tkopts)))
 
-	localRepo, err := pr.embedded.Repository(ctx, name)
+	localRepo, err := pr.embedded.Repository(ctx, localRepositoryName)
 	if err != nil {
 		return nil, err
 	}
@@ -146,7 +171,7 @@ func (pr *proxyingRegistry) Repository(ctx context.Context, name reference.Named
 		return nil, err
 	}
 
-	remoteRepo, err := client.NewRepository(name, pr.remoteURL.String(), tr)
+	remoteRepo, err := client.NewRepository(remoteRepositoryName, pr.remoteURL.String(), tr)
 	if err != nil {
 		return nil, err
 	}
@@ -158,21 +183,23 @@ func (pr *proxyingRegistry) Repository(ctx context.Context, name reference.Named
 
 	return &proxiedRepository{
 		blobStore: &proxyBlobStore{
-			localStore:     localRepo.Blobs(ctx),
-			remoteStore:    remoteRepo.Blobs(ctx),
-			scheduler:      pr.scheduler,
-			repositoryName: name,
-			authChallenger: pr.authChallenger,
+			localStore:           localRepo.Blobs(ctx),
+			remoteStore:          remoteRepo.Blobs(ctx),
+			scheduler:            pr.scheduler,
+			localRepositoryName:  localRepositoryName,
+			remoteRepositoryName: remoteRepositoryName,
+			authChallenger:       pr.authChallenger,
 		},
 		manifests: &proxyManifestStore{
-			repositoryName:  name,
-			localManifests:  localManifests, // Options?
-			remoteManifests: remoteManifests,
-			ctx:             ctx,
-			scheduler:       pr.scheduler,
-			authChallenger:  pr.authChallenger,
+			localRepositoryName:  localRepositoryName,
+			remoteRepositoryName: remoteRepositoryName,
+			localManifests:       localManifests, // Options?
+			remoteManifests:      remoteManifests,
+			ctx:                  ctx,
+			scheduler:            pr.scheduler,
+			authChallenger:       pr.authChallenger,
 		},
-		name: name,
+		localRepositoryName: localRepositoryName,
 		tags: &proxyTagService{
 			localTags:      localRepo.Tags(ctx),
 			remoteTags:     remoteRepo.Tags(ctx),
@@ -189,6 +216,57 @@ func (pr *proxyingRegistry) BlobStatter() distribution.BlobStatter {
 	return pr.embedded.BlobStatter()
 }
 
+func (pr *proxyingRegistry) getRemoteRepositoryName(name reference.Named) (reference.Named, error) {
+	repoName := name.String()
+
+	// If localPathAlias is empty, no changes to the remote repository
+	if pr.localPathAlias == "" {
+		return name, nil
+	}
+
+	// If localPathAlias is not empty, replace it with remotePathOnly
+	if strings.HasPrefix(repoName, pr.localPathAlias) {
+		newRepoName := pr.remotePathOnly + strings.TrimPrefix(repoName, pr.localPathAlias)
+		remoteRepositoryName, err := reference.WithName(newRepoName)
+		if err != nil {
+			return nil, distribution.ErrRepositoryNameInvalid{
+				Name:   newRepoName,
+				Reason: err,
+			}
+		}
+		return remoteRepositoryName, nil
+	}
+
+	return name, nil
+}
+
+func (pr *proxyingRegistry) repositoryIsAllowed(name reference.Named) (bool, error) {
+	// Skip if remotePathOnly is empty
+	if pr.remotePathOnly == "" {
+		return true, nil
+	}
+
+	repoName := name.String()
+	allowedPrefix := pr.remotePathOnly
+
+	// If localPathAlias is not empty, use it as the prefix
+	if pr.localPathAlias != "" {
+		allowedPrefix = pr.localPathAlias
+	}
+
+	// Check if the repository name has the allowed prefix
+	if !strings.HasPrefix(repoName, allowedPrefix) {
+		return false, distribution.ErrRepositoryUnknownWithReason{
+			Name: repoName,
+			Reason: fmt.Errorf(
+				"allowed prefix is '%s'",
+				allowedPrefix,
+			),
+		}
+	}
+	return true, nil
+}
+
 // authChallenger encapsulates a request to the upstream to establish credential challenges
 type authChallenger interface {
 	tryEstablishChallenges(context.Context) error
@@ -240,10 +318,10 @@ func (r *remoteAuthChallenger) tryEstablishChallenges(ctx context.Context) error
 // locally, or pulling it through from a remote and caching it locally if it doesn't
 // already exist
 type proxiedRepository struct {
-	blobStore distribution.BlobStore
-	manifests distribution.ManifestService
-	name      reference.Named
-	tags      distribution.TagService
+	blobStore           distribution.BlobStore
+	manifests           distribution.ManifestService
+	localRepositoryName reference.Named
+	tags                distribution.TagService
 }
 
 func (pr *proxiedRepository) Manifests(ctx context.Context, options ...distribution.ManifestServiceOption) (distribution.ManifestService, error) {
@@ -255,7 +333,7 @@ func (pr *proxiedRepository) Blobs(ctx context.Context) distribution.BlobStore {
 }
 
 func (pr *proxiedRepository) Named() reference.Named {
-	return pr.name
+	return pr.localRepositoryName
 }
 
 func (pr *proxiedRepository) Tags(ctx context.Context) distribution.TagService {
diff --git a/registry/proxy/proxyregistry_test.go b/registry/proxy/proxyregistry_test.go
new file mode 100644
index 00000000..7aa602b7
--- /dev/null
+++ b/registry/proxy/proxyregistry_test.go
@@ -0,0 +1,155 @@
+package proxy
+
+import (
+	"github.com/distribution/reference"
+	"testing"
+)
+
+func TestGetRemoteRepositoryName(t *testing.T) {
+	tests := []struct {
+		name             string
+		remotePathOnly   string
+		localPathAlias   string
+		repoName         string
+		expectedRepoName string
+		expectError      bool
+	}{
+		{
+			name:             "No alias, no path change",
+			remotePathOnly:   "",
+			localPathAlias:   "",
+			repoName:         "myrepo",
+			expectedRepoName: "myrepo",
+			expectError:      false,
+		},
+		{
+			name:             "Alias exists, path updated",
+			remotePathOnly:   "remote",
+			localPathAlias:   "local",
+			repoName:         "local/repo",
+			expectedRepoName: "remote/repo",
+			expectError:      false,
+		},
+		{
+			name:             "Alias exists but no match",
+			remotePathOnly:   "remote",
+			localPathAlias:   "local",
+			repoName:         "other/repo",
+			expectedRepoName: "other/repo",
+			expectError:      false,
+		},
+		{
+			name:             "Alias without remotePathOnly",
+			remotePathOnly:   "",
+			localPathAlias:   "local",
+			repoName:         "local/repo",
+			expectedRepoName: "",
+			expectError:      true,
+		},
+	}
+
+	for _, tt := range tests {
+		t.Run(tt.name, func(t *testing.T) {
+			pr := &proxyingRegistry{
+				remotePathOnly: tt.remotePathOnly,
+				localPathAlias: tt.localPathAlias,
+			}
+
+			name, _ := reference.WithName(tt.repoName)
+			result, err := pr.getRemoteRepositoryName(name)
+
+			if tt.expectError {
+				if err == nil {
+					t.Errorf("expected error but got none")
+				}
+			} else {
+				if err != nil {
+					t.Errorf("did not expect error but got %v", err)
+				}
+				if result.String() != tt.expectedRepoName {
+					t.Errorf("expected repo name %s, but got %s", tt.expectedRepoName, result.String())
+				}
+			}
+		})
+	}
+}
+
+func TestRepositoryIsAllowed(t *testing.T) {
+	tests := []struct {
+		name            string
+		remotePathOnly  string
+		localPathAlias  string
+		repoName        string
+		expectedAllowed bool
+		expectError     bool
+	}{
+		{
+			name:            "Allowed repository without remotePathOnly option",
+			remotePathOnly:  "",
+			localPathAlias:  "",
+			repoName:        "remote/repo",
+			expectedAllowed: true,
+			expectError:     false,
+		},
+		{
+			name:            "Allowed repository without alias",
+			remotePathOnly:  "remote",
+			localPathAlias:  "",
+			repoName:        "remote/repo",
+			expectedAllowed: true,
+			expectError:     false,
+		},
+		{
+			name:            "Allowed repository with alias",
+			remotePathOnly:  "remote",
+			localPathAlias:  "local",
+			repoName:        "local/repo",
+			expectedAllowed: true,
+			expectError:     false,
+		},
+		{
+			name:            "Not allowed repository",
+			remotePathOnly:  "remote",
+			localPathAlias:  "",
+			repoName:        "other/repo",
+			expectedAllowed: false,
+			expectError:     true,
+		},
+		{
+			name:            "Not allowed with alias",
+			remotePathOnly:  "remote",
+			localPathAlias:  "local",
+			repoName:        "other/repo",
+			expectedAllowed: false,
+			expectError:     true,
+		},
+	}
+
+	for _, tt := range tests {
+		t.Run(tt.name, func(t *testing.T) {
+			pr := &proxyingRegistry{
+				remotePathOnly: tt.remotePathOnly,
+				localPathAlias: tt.localPathAlias,
+			}
+
+			name, _ := reference.WithName(tt.repoName)
+			result, err := pr.repositoryIsAllowed(name)
+
+			if tt.expectError {
+				if err == nil {
+					t.Errorf("expected error but got none")
+				}
+				if result {
+					t.Errorf("expected false, but got true")
+				}
+			} else {
+				if err != nil {
+					t.Errorf("did not expect error but got %v", err)
+				}
+				if result != tt.expectedAllowed {
+					t.Errorf("expected %v, but got %v", tt.expectedAllowed, result)
+				}
+			}
+		})
+	}
+}
